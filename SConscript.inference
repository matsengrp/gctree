#! /usr/bin/env python
# -*- coding: utf-8 -*-
"""
Infer trees from germinal center data
"""
import os
import atexit
import shutil
import re


def which(executable):
    for path in os.environ["PATH"].split(os.pathsep):
        if os.path.exists(os.path.join(path, executable)):
            return os.path.realpath(os.path.join(path, executable))
    return None


# the following must be exported by parent SConstruct/SConscript
Import(
    "env dnaml quick idlabel frame input_file input_file2 outdir root_id id_abundances CommandRunner bootstrap xarg buffarg colorfile mutability substitution disambiguate_with_mutability"
)


def delete_on_failure():
    from SCons.Script import GetBuildFailures

    for bf in GetBuildFailures():
        try:
            if False:  # Turn on if failed folder should be deleted
                # shutil.rmtree(os.path.dirname(bf.node.abspath))
                print("There was an error for target:", bf.node.abspath)
                print(
                    "To resolve this the base folder was deleted. "
                    "Restarting will possibly solve the issue in case "
                    "this was just a bad simulation. Deleted folder:",
                    os.path.dirname(bf.node.abspath),
                )
        except OSError:
            pass  # Allow this


# atexit.register(delete_on_failure)

return_list = []


if input_file2 is not None:
    basename = "combined"
elif isinstance(input_file, str):
    basename = ".".join(os.path.basename(input_file).split(".")[:-1])
else:
    basename = "gctree.simulation"
frame_arg = " --frame {} ".format(frame) if frame is not None else ""
id_abundances_arg = (
    " --id_abundances " if id_abundances is not None else ""
)
phylip = env.Command(
    [
        os.path.join(
            outdir, os.path.splitext(os.path.basename(input_file))[0] + ".phylip"
        )
        if input_file2 is None and isinstance(input_file, str)
        else os.path.join(outdir, "gctree.combined.phylip")
        if input_file2 is not None
        else os.path.join(outdir, "gctree.simulation.phylip"),
        os.path.join(outdir, basename) + ".counts",
        os.path.join(outdir, basename) + ".idmap",
    ]
    + (
        [os.path.join(outdir, basename) + ".colormap"]
        if colorfile is not None
        else []
    ),
    input_file if colorfile is None else [input_file, colorfile],
    buffarg
    + "deduplicate ${SOURCES[0]} "
    + (" --colorfile ${SOURCES[1]} " if colorfile is not None else "")
    + (" --colormap ${TARGETS[3]} " if colorfile is not None else "")
    + " --abundance_file ${TARGETS[1]} --idmapfile ${TARGETS[2]} "
    + frame_arg
    + id_abundances_arg
    + "--root "
    + root_id
    + " > ${TARGETS[0]}",
)

if bootstrap:

    if dnaml:
        raise NotImplementedError("bootstrap not implemented for dnaml")

    bootstrap_arg = " --bootstrap {} ".format(bootstrap)
    seqboot_config = env.Command(
        os.path.join(outdir, "seqboot/config.cfg"),
        phylip[0],
        buffarg
        + "mkconfig ${SOURCE} seqboot "
        + bootstrap_arg
        + " > $TARGET".format(bootstrap),
    )

    seqboot = CommandRunner(
        [os.path.join(outdir, x) for x in ["seqboot/outfile", "seqboot/log.log"]],
        seqboot_config,
        "cd "
        + outdir
        + "/seqboot && rm -f outfile && seqboot < ${SOURCE.file} > ${TARGETS[1].file}",
    )
    # Manually depend on phylip so that we rerun seqboot if the input sequences change (without this, dnaml will
    # only get rerun if one of the targets are removed or if the input dnaml_config file is changed).
    env.Depends(seqboot, phylip)

# Update the root ID:
root_id = root_id

if dnaml:
    dnaml_config = env.Command(
        os.path.join(outdir, "dnaml/config.cfg"),
        phylip[0],
        buffarg + "mkconfig ${SOURCE} dnaml > $TARGET",
    )

    # run dnaml (from phylip package) to generate maximum likelihood tree
    dnaml = CommandRunner(
        [
            os.path.join(outdir, x)
            for x in ["dnaml/outtree", "dnaml/outfile", "dnaml/log.log"]
        ],
        dnaml_config,
        "cd "
        + outdir
        + "/dnaml && rm -f outfile outtree && dnaml < ${SOURCE.file} > ${TARGETS[2].file}",
    )
    # Manually depend on phylip so that we rerun dnaml if the input sequences change (without this, dnaml will
    # only get rerun if one of the targets are removed or if the input dnaml_config file is changed).
    env.Depends(dnaml, phylip)

    dnaml_tree = env.Command(
        [
            os.path.join(outdir, "dnaml.inferred_tree.p"),
            os.path.join(outdir, "dnaml.inferred_tree.log"),
        ],
        [dnaml[1], phylip[1]],
        xarg
        + "phylip_parse ${SOURCES} --outputfile ${TARGETS[0]} --root "
        + root_id
        + " > ${TARGETS[1]}",
    )
    return_list.append(dnaml_tree)


# make config file for dnapars
quick_arg = " --quick " if quick else ""
dnapars_config = env.Command(
    os.path.join(outdir, "dnapars/config.cfg"),
    phylip[0],
    buffarg
    + "mkconfig ${SOURCE} dnapars "
    + quick_arg
    + " > $TARGET",
)

# run dnapars (from phylip package) to generate parsimony trees
dnapars = CommandRunner(
    [
        os.path.join(outdir, x)
        for x in ["dnapars/outtree", "dnapars/outfile", "dnapars/log.log"]
    ],
    dnapars_config,
    "cd "
    + outdir
    + "/dnapars && rm -f outfile outtree && dnapars < ${SOURCE.file} > ${TARGETS[2].file}",
)
# Manually depend on phylip so that we rerun dnapars if the input sequences change (without this, dnapars will
# only get rerun if one of the targets are removed or if the input dnapars_config file is changed).
env.Depends(dnapars, phylip)

# ML tree from parsimony trees
# NOTE: xvfb-run is needed because of issue https://github.com/etetoolkit/ete/issues/101
# NOTE: TMPDIR is needed due for xvfb

if bootstrap:
    dnapars_config_bootstrap = env.Command(
        os.path.join(outdir, "dnapars_bootstrap/config.cfg"),
        seqboot[0],
        buffarg
        + "mkconfig ${SOURCE} dnapars "
        + quick_arg
        + bootstrap_arg
        + " > $TARGET",
    )
    dnapars_bootstrap = CommandRunner(
        [
            os.path.join(outdir, x)
            for x in [
                "dnapars_bootstrap/outtree",
                "dnapars_bootstrap/outfile",
                "dnapars_bootstrap/log.log",
            ]
        ],
        dnapars_config_bootstrap,
        "cd "
        + outdir
        + "/dnapars_bootstrap && rm -f outfile outtree && dnapars < ${SOURCE.file} > ${TARGETS[2].file}",
    )
    env.Depends(dnapars_bootstrap, seqboot)

gctree_outbase = os.path.join(outdir, "gctree")
frame_arg = " --frame {} ".format(frame) if frame is not None else ""
idlabel_arg = " --idlabel" if idlabel else ""
mutabilitymodel = " --mutability {}".format(mutability) if mutability else ""
substitutionmodel = " --substitution {}".format(substitution) if substitution else ""
gctree_infer = CommandRunner(
    [
        gctree_outbase + ".inference.parsimony_forest.p",
        gctree_outbase + ".inference.log",
    ],
    [dnapars[1], phylip[1]]
    + ([dnapars_bootstrap[1]] if bootstrap else [])
    + ([phylip[3]] if colorfile is not None else []),
    xarg
    + buffarg
    + "gctree infer --verbose ${SOURCES[0]} ${SOURCES[1]} --root "
    + root_id
    + " --outbase "
    + gctree_outbase
    + frame_arg
    + idlabel_arg
    + (" --colormap ${SOURCES[-1]} " if colorfile is not None else "")
    + (" --bootstrap_phylipfile ${SOURCES[2]}" if bootstrap else "")
    + (" --disambiguate_with_mutability" if disambiguate_with_mutability else "")
    + mutabilitymodel
    + substitutionmodel
    + " | tee ${TARGETS[1]}",
)
return_list.append(gctree_infer)

Return("return_list")
